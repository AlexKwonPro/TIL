# Algorithm 🎁

## 알고리즘의 시작

> 1일차 : Algorithm Problem Solving

`APS 기본`

### 배열 1 (Array 1)

* 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법. 주로 컴퓨터 용어로 쓰이며, 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법.





이게 100이라 망정이지 억이면 알고리즘 2는 항상 연산 3번이라 엄청 차이남.



실제 걸리는 시간은 컴마다 성능 달라서 조금 차이가 있을 수 밖에 없음.

그래서 실행되는 명령문의 `개수`를 계산하게 됨.

빅 오 = 최악의 경우에 이정도 걸릴 거라는 것.



상수 4 같은 경우는 상수 1로 표현해서 O (1) 나옴.

아까 가우스 덧셈 같은게 O (1).

입력과 출력을 계산에 넣느냐는 좀 의견이 분분하긴 한데, n개 데이터 1씩 증가시킨다 이러면 O(n) 인데 입출력 전부 고려한다해도 O(3n) 이라서 계수무시하면 같음.



버블정렬은 n² 인데 얜 개오래 걸림. 

https://noahlogs.tistory.com/27

* **배열이란 무엇인가?**



물론 파이썬은 이것저것 리스트에 잡다한거 집어넣을 수 있지만 일반적으로 다른 언어들은 해당 변수는 이 자료형이다 라는걸 표현하고 이걸 일정하게 모아놔야 array가 돼서 그럼.

일일히 변수 지정하는거보다 array 집어넣는게 좋다는 그림 의미.



idx 넘어가면 index error.

---

* Q. Gravity







---

### 정렬 🥇

> 2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰값 혹은 그 반대의 순서대로 재배열 하는것.



#### 버블정렬 🧼



아무 언급이 없으면 오름차순으로 한다. 

2회만 했는데도 이렇게 됐는데? 정렬 다 된거 아닌가?



컴퓨터는 이어서 정렬을 함. 사실 1회는 맨 마지막 숫자가 정렬됐음을 보장할 뿐. 3번째 사이클 돌때 42까지 정렬이 된것. 4번째 사이클때 7 12 비교하게됨!. 

마지막 7이라는 값이 남았는데 얘는 정렬이 '`불필요`'함.

5개 정렬시 4개 사이클만 돌아보면 된다가 결론.



이런식으로 순차교환이 스왑인데 파이선은 튜플 식으로 해도 스왑 되어서 편함.

---

#### 카운팅 정렬



count 배열 만들건데, 가장 큰 정수값을 알아야함.
4가 제일 큰데? 빅오는 리스트길이 + 최대정수 



누적합 한다음 뒤에서부터읽어옴

temp는 내가 정렬하고싶은똑같은 크기의 배열ㅋ



뒤부터 정렬하면 장점이 있음 :  안정정렬.

동일한 값이 있을때 그 순서를 유지하기 위해서 뒤에서부터 정렬하는것.

> 근데 카운팅정렬은 [1,2,1억] 이러면 엄청 비효율적임. 최댓값이 적당히 적을때 써야 개빠름.



첫번째 포문은 카운팅 포문 (len(a)) 여도 상관없음

그다음 포문은 누적함 구하는 반복문. 첫번째 원소는 건드리지않으니까 1번부터 시작하는것. (1, ) 이부분

세번째 포문은 완벽한 정렬. 두번째가 -1 은 0번 인덱스까지 가라는것.

---

#### 완전검색



* 정렬한 후 비교 ? 123123 은 보자마자 run 2개인데 112233 이라고 정렬하면 짜증나짐. -> greedy 에서의 실수중 하나.



이런식으로 모든경우 나열하고 팩토리얼로 치면 720개긴 한데.. 이런식으로 전부 테스트하는것.

아래는 이런식으로 뽑아보면 1개의 예제에서 baby-gin이 아니라는 뜻.



이경우 중복순열 안할거니까 -> 3개 다 다른값이 됐을때만 튜플안에 담길 수 있는 조건.

근데이거 숫자 커지면 노답임. 재귀로 하는등의 방법이 있음.



지금은 인덱스로!



파이썬에선 tri 검사때 == 로 3개 둬도 됨.

false 값으로 초기화 했으니까! 이렇게 가능.

---

#### Greedy 알고리즘



이런식.  6개 주면 값을 구할 수 있더라! 최선이다! 라고 말할 수 있나? 큰돈부터 하나씩 쥐어주고 너무 많이주면 회수해서 작은거 주고.. 이런식으로. 이 문제의 경우에는 yes! 가 답인데? 최적경우.

그런데, 거슬러줄 수 있는 동전의 종류가 하나 더있다고 치면? 400원짜리라고 하면 ?  아까 방식으로 하면 답은 뭐 변하지 않는데.. 사실은 400 3개 50 1개 10 1개 주는게 더 최적인데?!

제일 큰 동전부터 주다보니 6개가 최적이라 착각.

애초에 가능했던게 배수 관계였기 때문! 100과 500은 배수관계라 무조건 주는게 나아서. 근데 500 400 은 서로가 배수관계가 아니기 때문에 문제가 생김. 

> 이럴땐 `완전탐색` 을 이용해야함!!!

---

Q. 한번 해보기. 6중 포문이 될거같은데?



---

Q. 탐욕 알고리즘의 예 -> 아까 베이비진 문제 풀이.

트리플릿 검사가 더 간편할 수 있음.  모든 경우를 확인하지 않고도 베이비 진을 구현해 낼 수 있다는 장점이 있음.



여기서 c = [0] * 12가 왜 12인지 생각해보고 10으로 해도 됨조건이 좀 더 들어가야 겠지만!



문제는 이런애들 문자열 받고 int 화 하면 앞에 0 이 사라져 버리잖아?! 주의해야함. 

`입력`



int 해주기 전엔 저렇다가



map int 이렇게 뿌려주면 들어감. 근데 요게 정석이긴 함.

 요소가 되어버림.



이렇게 해야함!!



* 붙어져 들어오는걸 찢을때는?



다만 주의할건 이경우 찢는다 해도 문자열임



그러니까..  스트링도 iterable 하긴 하니까?



<연습>



이제 이런거 받아볼거. 3은 전체 테스트 케이스 수.

그리고 9는 원소 갯수!

문제번호까지 할거면 이런식으로.



tc+1 로 조정하든가, 위에 포문에서 T에서 T+1 하든가.
range(1, T+1)

이걸 인풋을 한방에 넣어도 됨. 그냥 input에 반응하는 느낌이라 하나씩 코드 돌아갈때마다 가져 씀.



일단 인풋.. 이렇게 일일히 하기 힘들면 이렇게 해도됨.

